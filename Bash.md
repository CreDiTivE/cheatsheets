Синтаксис Bash
==============

**Bash** (Bourne again shell) командный процессор разработанный в рамках проекта GNU(GNU's Not UNIX).


Запуск
------

Если bash запущен как login-shell, то он выполняет:

1. `/etc/profile` (если существует)
2. `~/.bash_profile` (если такого файла нет, перейти к следующему шагу)
3. `~/.bash_login` (если такого файла нет, перейти к следующему шагу)
4. `~/.profile`

Если bash запущен как обыкновенный интерактивный командный процессор,
то при старте он выполняет только `~/.bashrc`.

История запуска команд
----------------------

Историю команд bash хранит в файле `~/.bash_history`.
Посмотреть историю введенных команд можно выполнив в bash `history`.
По умолчанию bash хранит историю о последних 2000 команд (`echo $HISTFILESIZE`).

Псевдонимы команд
-----------------

Псевдонимы команд это сокращения для часто используемых последовательностей команд или длинных команд.

Создать псевдоним `alias <псевдоним>='<команда>'`.
Отменить псевдоним назначенный командой `unalias [псевдоним]`.

Шаблоны в командах
------------------

* `*` - любая подстрока, в том числе пустая;
* `?` - один любой символ;
* `[a-z]` - один любой символ из списка.

Например, отобразить все файлы Python в текущем каталоге:

    ls -l *.py

Первый скрипт на Bash
---------------------

Создадим файл скрипта:

    touch hello.sh

Назначим права на выполнение:

    chmod +x hello.sh

Откроем скрипт для редактирования и добавим текст:

    #!/bin/bash
    echo "Hello world!"
    
Выполним скрипт, на экране должно отобразится `Hello world!`:
    
    ./hello.sh


Перенаправление потоков вывода
------------------------------

| Поток вывода | Приемник | Синтаксис |
|--------------|----------|-----------|
| `stdout` | файл | `> out.txt` или `1> out.txt` |
| `stderr` | файл | `2> out.txt` |
| `stdout` | `stderr` | `1>&2` |
| `stderr` | `stdout` | `2>&1` |
| `stderr` и `stdout` | файл | `&> out.txt` |

Пример. Отобразить содержимое каталога на экране и сохранить в файле:

    ls -l >&1 | tee out.txt

В этом примере мы выводим содержимое каталога, этот вывод передается в поток вывода(`&1`), далее с помощью канала в файл. Канал сам по себе не может записать данные в файл, для этого можно использовать команду `tee`, которая принимает поток ввода и передает его на вывод в файл.

Каналы
------

Каналы позволяют передать результат выполнения одной команды в другую, объединяя выполнение разных команд в последовательность. Для присоединения одной команды к другой используется символ `|`.

Например, прочитать содержимое файла и отобразить его с возможностью навигации вперед-назад на экране:

    cat /var/log/syslog | less
    
Переменные
----------

Переменные в Bash не имеют типа как такового, но могут быть: числом, символом или строкой.

### Создание, удаление и экспорт

Объявление переменных и отображение результата `Hello world!`:

    VAR1="Hello"
    VAR2=world!
    echo "$VAR1 $VAR2"
    
Сохранить ввод пользователя в переменную:

    echo -n "Please, enter your name: "
    read NAME
    echo $NAME
    
Сохранить ввод пользователя в несколько переменных:

    echo -n "Please, enter your firstname and lastname: "
    read FIRSTNAME LASTNAME
    echo "Hello $FIRSTNAME $LASTNAME!"

Конкатенация значений, отобразит список файлов в каталоге:

    CMD="ls"
    CMD+=" -l"
    $CMD

Можно сделать переменную доступной процессам-потомкам, для этого ее нужно экспортировать.

    export MY_VAR

Удалить значение переменной можно командой `unset`, либо присвоив ей пустое значение:

    unset MY_VAR

### Вычисляемое выражение в переменных

Переменные могут содержать результат выполнения команды заключенный в выражение `$()`. 

Например, создадим уникальное имени файла, при архивации данных:

    FILENAME=backup-$(date +%Y%m%d).tar.gz
    tar -zcvf $FILENAME folder/
    
Другой способ получения результата выражения, заключать команду в обратные апострофы `` ` ` ``. 

Например, остановить выполнение программы:

    kill -9 `cat /var/run/script.pid`

### Локальные переменные

Можно объявлять локальные переменные внутри функции.

Например, этот скрипт выведет `Alice Matt Alice`.

    NAME=Alice
    function myname {
        local NAME=Matt
        echo $NAME
    }
    echo $NAME
    myname
    echo $NAME

### Переменные среды окружения

У каждого запущенного процесса в UNIX есть своя среда окружения (environment). Среда окружения это набор переменных имя-значение которые доступны для чтения и изменения процессу.

| Переменная | Описание                                           |
|------------|----------------------------------------------------|
| `$0`       | имя запущенного скрипта |
| `$1` ... `$9` | имена позиционных агрументов переданных скрипту |
| `$$`        | PID текущего процесса |
| `$*`        | все переданные параметры |
| `$#`        | количество переданных параметров |
| `$?`        | код завершения последней инструкции |
| `$!`        | номер последнего процесса запущенного в текущей сессии в фоновом режиме |
| `$_`        | последняя вызванная команда |
| `$HOME`     | домашний каталог пользователя |
| `$PWD`      | текущий каталог |
| `$UID`      | идентификатор пользователя запустивщего сценарий |
| `$RANDOM`   | случайное число от 0 до 32767 |
| `$REPLY`    | последняя строка введенная с помощью read |
| `$SHELL`    | текущий командный процессор |
| `$PS1`      | вид приглашения командного процессора |
| `$PS2`      | вид приглашения «продолжения команды» |
| `$TERM`     | тип терминала пользователя |
| `$USER`     | имя пользователя |
| `$PATH`     | список каталогов для поиска запускаемых программ (разделяются двоеточием) |

Условный оператор if..else
---------------------------

    if [ $USER = "alice" ]; then
        echo "Hello Alice!"
    elif [ $USER = "matt" ]; then
        echo "Hello Matt!"
    else
        echo "Hello friend!"
    fi

Оператор выбора select
----------------------

С помощью оператора `select` можно реализовать консольный интрефейс выбора действия.

Например, выбрать какое действие необходимо выполнить:

    OPTIONS="start stop reload"
    select opt in $OPTIONS; do
        if [ "$opt" = "start" ]; then
            echo $opt
            exit
        elif [ "$opt" = "stop" ]; then
            echo $opt
            exit
        elif [ "$opt" = "reload" ]; then
            echo $opt
            exit
        fi
    done

Оператор множественного ветвления case in
-----------------------------------------

    ACTION=$1
    case "$ACTION" in
    start) echo "Start server"
    ;;
    stop) echo "Stop server"
    ;;
    reload) echo "Reload server"
    ;;
    *) echo "No action";
    esac

Циклы for, while и until
--------------------------

Цикл `for` позволяет делать обход последовательностей.

Например, вывести содержимое каталога:

    for i in $( ls ); do
        echo item: $i
    done
    
Например, вывести по порядку числа от 1 до 10:

    for i in `seq 1 10`;
    do
        echo $i
    done
    
Цикл `while` выполняется пока значение выражения возвращает истину.

    COUNTER=0
    while [  $COUNTER -lt 10 ]; do
        echo counter: $COUNTER
        let COUNTER=COUNTER+1
    done
    
Цикл `until` выполняется пока выражение возвращает ложь.

    COUNTER=20
    until [  $COUNTER -lt 10 ]; do
        echo COUNTER $COUNTER
        let COUNTER-=1
    done
    
Выражения для формирования условий

| Условие | Описание |
|---------|----------|
| -d <имя> | истина, если указанное имя является именем каталога |
| -е <файл> | истина, если файл существует |
| -L <файл> | истина, если файл существует и является ссылкой |
| -s <файл> | истина, если файл существует и не пустой (размер больше 0) |
| -х <файл> | истина, если файл существует и является исполнимым |
| -w <файл> | истина, если файл существует и доступен для записи |
| -z переменная | истина, если строка, содержащаяся в переменной, является пустой (ее длина равна 0) |
| -n переменная | истина, если строка, содержащаяся в переменной, не является пустой (ее длина больше 0) |
| переменная -eq значение | равно |
| переменная -ne значение | не равно |
| переменная -lt значение | меньше |
| переменная -gt значение | больше |
| переменная -le значение | меньше или равно |
| переменная -ge значение | больше или равно |

Функции
-------

Функции в bash являются именнованными блоками кода и могут принимать входные параметры.

Например, функция вычисляющая сумму двух чисел:

    function summ {
        local result=0
        if [ $# -eq 2 ]; then
            echo $(($1 + $2))
            return 0
        else
            echo "Error! You must pass two numbers."
            return 1
        fi
    }
    
    SUMM=$(summ 10)
    echo $? # код завершения, то что вернул return
    echo $SUMM # значение которое вернула функция через echo
    
Арифметические операции
-----------------------

Сложить два числа:

    A=1
    B=2
    echo $[$A + $B] # первый способ
    echo $((A + B)) # второй способ

Доступные операторы

* `+` - сложение
* `-` - вычитание
* `*` - умножение
* `/` - деление
* `%` - остаток от деления

Для вычисления дробных значений придется использовать дополнительные команды.

Например, вычислить дробное значение:

    echo 1/2 | bc -l # вернет .50000000000000000000
