Основы GIT
==========

Базовые понятия
---------------

Состояния файлов под версионным контролем:

* Измененный (файл изменен, но еще не зафиксирован)
* Подготовленный (измененные файлы, отмеченные для включенные в следующий коммит)
* Зафиксированный (файл уже сохранен в локальной базе)

Рабочие области:

* Working directory (рабочий каталог, извлечённая из базы копия определённой версии проекта)
* Staging area (область подготовленных файлов, файл представляющий информацию о том, что должно войти в следующий коммит)
* Git directory (каталог git, место хранения метаданных и базы данных объектов вашего проекта)

Настройка
---------

### Файлы настроек

* `/etc/gitconfig` содержит значения, общие для всех пользователей системы и для всех их репозиториев (`git config --system`).
* `~/.gitconfig` хранит настройки конкретного пользователя (`git config --global`).
* `.git/config` конфигурационный файл репозитория (`git config`).

### Настройка имени пользователя

    git config --global user.name "<имя>"
    git config --global user.email <эл.почта>

### Настройка редактора

    git config --global core.editor mcedit

### Утилита сравнения

    git config --global merge.tool vimdiff

### Вывод настроек

    git config --list
    git config user.name
    git config <ключ>

### Вызов справки

    git help <команда>

Репозиторий
-----------

### Создание репозитория

    git init
    git init <каталог>
    git init --bare <каталог> # репозиторий создаваемый как удаленный, не содержит рабочей директории с файлами

### Клонирование репозитория

    git clone <url> <каталог>
    git clone /home/username/project.git <каталог>
    git clone git://user@somehost:port/~user/repository/project.git <каталог>

### Добавление файлов в репозиторий

Многофункциональная команда `git add` используется для добавления файлов в репозиторий и индексации изменений файлов.

    git add <файл|каталог>

### Удаление файлов из репозитория

    git rm <файл> # удаляет файл из индекса и диска
    git rm -f <файл> # принудительное удаление (поможет удалить файл с проиндексированными изменениями еще не зафиксированный комиттом)
    git rm --cached <файл> # удаляет файл из индекса

### Игнорирование файлов

В файле `.gitignore` можно указать список файлов или шаблонов неотслеживаемых файлов.

    cat .gitignore
    .idea/*
    *.py[co]

### Состояние репозитория

    git status
    git status -uno # без файлов не включенных в репозиторий

### Лог изменений

    git log -1 # последняя запись в логе изменений
    git log -p # дельта изменений
    git log --word-diff # изменения на уровне слов, а не строк
    git log --stat # выводит под каждым коммитом список изменённых файлов и количество изменений
    git log --pretty=oneline # выводит каждый коммит в одну строку
    git log --pretty="format:%h %an %ad %s" # выводит сокращенный хеш, имя автора, дату, комментарий

### Просмотр изменений между файлами

    git diff # разница между файлами в рабочем каталоге и репозитории
    git diff HEAD~1 HEAD # разница между последним и предпоследним коммитами
    git diff --staged # узнать что войдет в новый коммит

### Фиксация изменений

    git commit -m <сообщение>
    git commit -a -m <сообщение> # добавляет все измененные файлы в индекс и делает коммит

### Отмена изменений

    git commit --amend -m # изменяет последний коммит (меняет комментарий и хеш коммита)
    git reset <хэш|файл>
    git reset HEAD # сбросит состояние репозитория к последнему коммиту (будут забыты непроиндексированные изменения)
    git reset HEAD <файл> # сброс индекса файла к состоянию последнего коммита (сам файл не меняется)
    git checkout -- <файл> # сбрасывает файл к состоянию последнего коммита

### Перемещение и переименование файлов

    git mv <старый_файл> <новый_файл>


Удаленные репозитории
---------------------

Основной репозиторий по умолчанию имеет имя `origin`.
Получение данных из удаленного репозитория обозначется как `pull`, помещение данных как `push`.
Извлечение информации из удаленного репозитория обозначается как `fetch`

### Список удаленных репозиториев

    git remote
    git remote -v # список с информацией об URL для push и pull

### Добавление удаленного репозитория

    git remote add <название> <url>
    git remote add origin <url>

### Загрузить информацию из удаленного репозитория

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет.
После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта.
Теперь эти ветки в любой момент могут быть просмотрены или слиты.

Команда `fetch` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент.
Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

    git fetch <уд.репозиторий> <ветка>
    git fetch origin master

### Извлечь данные и слить их с локальной версией

Выполнение `git pull` извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

    git pull <уд.репозиторий> <ветка>
    git pull origin master

### Отправить данные в удаленный репозиторий

    git push <уд.репозиторий> <ветка>
    git push origin master

По умолчанию команда `push` не отправляет в репозиторий новые метки (tags), для их отправки необходимо выполнить:

    git push <метка>
    git push v0.4

    git push --tags # отправить все метки

### Информация об удаленном репозитории

    git remote show <уд.репозиторий>
    git remote show origin

### Переименовать удаленный репозиторий

    git remote rename <старое имя> <новое имя>

### Удалить удаленный репозиторий

    git remote rm <уд.репозиторий>

Метки
-----

*Легковеслая метка* - это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит.

*Аннотированные метки* хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG).
Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.

### Создание метки

Создание легковеслой метки:

    git tag <метка>
    git tag v0.0.1

Создание аннотированной метки:

    git tag -a <метка> -m <комментарий>
    git tag -a v0.0.1 -m 'My first version'

Выставить легковеслую метку для определенного коммита:

    git tag <метка> <хеш коммита>
    git tag v0.4 9fceb02

### Просмотр меток репозитория

    git tag

Для просмотра меток по шаблону используйте команду:

    git tag -l '<шаблон поиска>'
    git tag -l 'v1.4.2.*'

Ветки
-----

Ветка в Git — это просто легковесный подвижный указатель на один из этих коммитов. Ветка по умолчанию в Git называется `master`.
Когда вы создаёте коммиты на начальном этапе, вам дана ветка `master`, указывающая на последний сделанный коммит.
При каждом новом коммите она сдвигается вперёд автоматически.

В GIT существует специальный указатель `HEAD`, который ссылается на ветку на которой вы находитесь.

### Создать ветку

    git branch <имя ветки> # создаст новую ветку, но не переключит на нее репозиторий

    git branch dev # создать ветку dev
    git checkout dev # переключится на ветку dev

    git checkout -b <ветка> # создать ветку и переключить на нее репозиторий

### Удалить ветку

    git branch -d <ветка>
    git branch -D <ветка> # удалить неслитую ветку и потерять наработки

### Отобразить существующие ветки

    git branch # символ * указывает на текущую ветку
    git branch -v # список веток с последним коммитом на них
    git branch --merged # слитые ветки
    git branch --no-merged # не слитые ветки

### Переключение между ветками

    git checkout <ветка>

### Слияние изменений между ветками

    git checkout <ветка в которую сливаем изменения>
    git merge <ветка из которой сливаем изменения>

    git checkout master # переключится на ветку master
    git merge dev # в ветку master будут слиты изменения из ветки dev

### Разрешение конфликтов слияния

Слияние не всегда проходит гладко, если в репозиторий отправляются изменения одного и того же файла,
сделанные разными разработчиками может возникнуть конфликт слияния. GIT известит о конфликте следующим сообщением `'Automatic merge failed; fix conflicts and then commit the result.'`.

Ваши действия при конфликте слияния:

1. Определить в каких файлах произошел конфликт слияния (обычно они перечисляются при выполнении операции `git merge`);
2. Изменить конфликтующие файлы, убрав метки `<<<<<<< HEAD`, `=======`, `>>>>>>>` и оставив нужные данные;
3. Добавить измененные файлы в индекс `git add <файл>`;
4. Выполнить коммит измененных файлов `git commit`.

### Удаленные ветки

Удалённые ветки — это ссылки на состояние веток в ваших удалённых репозиториях.
Это локальные ветки, которые нельзя перемещать; они двигаются автоматически всякий раз, когда вы осуществляете связь по сети.
Удалённые ветки действуют как закладки для напоминания о том, где ветки в удалённых репозиториях находились во время последнего подключения к ним.

Удаленные ветки обычно имеют имя вида `<уд.репозиторий>/<ветка>`.

Полезные советы по работе с GIT
-------------------------------

### Автоподсказка при вводе команд

При вводе команды под Linux нажать два раза клавишу <Tab>. На экране отобразится список подсказок для ввода возможной команды.

### Псевдонимы команд

    git config --global alias.<псевдоним> '<команда>'
    git config --global alias.co 'checkout'
